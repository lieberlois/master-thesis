\section{GitOps}
\label{section:gitops}
    GitOps is one of the main trends in the DevOps ecosystem and integrates into the Continuous Integration/Continuous Delivery (CI/CD) process. It can be described as an operational framework that applies DevOps best practices and proves to be optimal for automation in distributed environments and hence fits like a glove for the IIoT use case due to the highly distributed nature of such systems. In the context of GitOps, the following key concepts should be noted:

    \begin{itemize}
        \item Declarative description of the desired state
        \item Immutable and versioned
        \item Automatically pulled
        \item Continuously reconciled
    \end{itemize}

    First of all, the desired state of all deployment targets is expressed through declarative configuration files. By avoiding the use of imperative code for CI/CD, the process becomes more reproducible and less error-prone due to common issues like race conditions or faulty dependencies. As the name suggests, the configuration is stored in Git, which means, that the system is strictly versioned and each version is immutable, just through the usage of Git. This allows the use of known and battle-tested workflows like using Git pull requests, mandatory code reviews, branch rules and allowed merge time windows. Also, the system automatically comes with an immutable audit trail, which ensures a comprehensive record of changes, enhancing both accountability and traceability. Contrary to the typical CI/CD process of using pipelines that push to delivery targets, the desired state in Git is automatically pulled from the so-called GitOps controllers running on the delivery targets themselves. This not only means, that pipelines become obsolete for the delivery process, it also is beneficial for security. While pipelines need access to delivery systems which typically means opening ports in firewalls and setting up pipeline agents in the same network as their delivery targets, GitOps delivery targets only need to have access to the Git repository storing their respective desired state because of the shift from the push to the pull model. Since CI/CD agents are a very attractive target for attackers due to their often high level of permissions and access, this is a great benefit. Also, the computational power of the delivery targets is used, so that less strain is placed on the central CI/CD infrastructure, resulting in more efficient resource utilization and potentially lower operational costs. Lastly, the GitOps controllers continuously reconcile all deployments. The divergence between the desired state described in Git and the actual state in the system is consistently monitored. If such a drift is detected, the GitOps controllers apply the necessary changes to realign the system with the specified state in Git \cite{lopez-viana_continuous_2022}. Here, the concept of eventual consistency comes in handy. Dependencies that would impose difficult challenges in building CI/CD pipelines can often be resolved by the automatic reconciliation of GitOps controllers. By retrying until success, many dependencies, which would have caused issues in typical pipelines, are resolved automatically.
    
    It is to be noted that GitOps is not a replacement but rather an addition to CI/CD pipelines. GitOps mainly deals with the delivery of software through configuration, whereas pipelines take over the continuous integration process, which yields artifacts required for the GitOps process. This includes tasks like building or compiling, running tests, building container images and changing configuration in Git. These artifacts are then applied by GitOps controllers based on the configuration and the artifacts provided by the pipelines earlier. Since this thesis focuses on the infrastructure of IIoT systems, the delivery aspect will be the main focus in this work though. \newline 

    % \subsection{Appliance in IIoT}

    Because GitOps is only based on Git and a GitOps controller, the infrastructure to which GitOps can be applied is varied, including cloud environments, bare-metal servers and more. Compared to traditional CI/CD pipelining, this allows for a uniform delivery process across all environments. This is particularly useful in IIoT since workloads are expected to run on a variety of infrastructure, ranging from edge devices (\autoref{section:edge-computing}) up to cloud or even multi-cloud solutions, where standard pipelines begin to struggle. As mentioned in \autoref{section:current-situation}, one of the key factors in modern IIoT systems is automation. Many claim that the GitOps model is the key framework to achieve the necessary level of automation on such scale. Being able to roll out software to a large variety of delivery targets at once and keeping all targets in sync with the desired state from the Git repository as the single source of truth, while keeping operational costs (DevOps teams, CI/CD agents, deployment schedule, etc.) low is crucial. Scaling to such an extent is not only tedious but in many scenarios infeasible with traditional CI/CD pipelining \cite{weaveworks_gitops_edge_all_clouds}. Improving continuous delivery is not the only benefit of GitOps though. By using Git as the single source of truth for all desired state, development productivity can be increased by a lot as well. With proper automation in place, platform or DevOps teams no longer become the bottleneck in large-scale projects, since every developer with access to Git is now able to manage the desired state without needing assistance. The developer experience can be improved even further by providing templates or reusable components for common tasks \cite{telekom_gitops_k8s_scale}.\newline

    However, with GitOps some new challenges are introduced as well. One of the most demanding ones is the chicken-egg problem introduced by having to run a GitOps controller on the infrastructure, that should be provisioned through GitOps. In practice, this is typically solved by setting up a temporary GitOps controller on an existing system or by bootstrapping the system manually once. Another limitation of this DevOps framework is that while it is one of the main trends in the DevOps community, it is mainly focused on the orchestration tool ``Kubernetes'' (see \autoref{section:orchestration-scheduling}). While common Git\-Ops technologies like ``FluxCD'' and ``ArgoCD'' fit perfectly for Kubernetes-based projects, systems using other orchestration technologies make the application of GitOps hardly possible. Lastly, provisioning infrastructure is in itself another challenge. For this, supporting tools have to be used. Infrastructure-as-Code (IaC) tools like ``ClusterAPI'', ``Crossplane'', ``OpenTofu'' or ``Pulumi'' enable developers to describe infrastructure in a declarative manner and manage the actual infrastructure under the hood. With such tools, not only software but also infra\-structure can be managed through GitOps thus once again moving one step closer to the goal of storing ``everything'' as code \cite{redhat_path_gitops}. How GitOps can be used to manage the infrastructure of a large-scale IIoT platform will be explored in \autoref{chapter:infrastructure-provisioning}.