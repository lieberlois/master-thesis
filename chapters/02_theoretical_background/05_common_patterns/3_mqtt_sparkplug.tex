\newpage
\subsection{Message Queuing Telemetry Transport and Sparkplug B}
    This section will deal with Message Queuing Telemetry Transport (MQTT) and the addition of Sparkplug B since they offer an interesting alternative to OPC-UA (\autoref{subsection:opc-ua}).

    \subsubsection{MQTT}
    \label{subsubsection:mqtt}
        
        MQTT is a simple and lightweight protocol. It was developed for highly constrained devices and unreliable networks with high latency and is widely accepted in the world of IoT today, especially since the release of MQTT 5. The protocol guarantees a secure and reliable data exchange in industrial automation and is hence perfectly suited for use in the digitalization of manufacturing and production. Similar to OPC-UA (\autoref{subsection:opc-ua}) MQTT is battle-tested and has even celebrated its 20th anniversary in 2019. The core principle of MQTT is publish-and-subscribe (pub-sub) where publishers send messages that are distributed to all consumers (subscribers) that are interested in the data. This is achieved using a hub-and-spoke model in which all communication is handled by a message-oriented middleware called the ``MQTT broker''. The broker handles needs such as redundancy, failover, high availability and scalability on the given infrastructure. MQTT clients (publishers and subscribers) in IIoT can for example be IoT gateways, edge devices or domain applications. They are loosely coupled since they only communicate via messages and only with the broker, not directly with each other. The broker can also manage MQTT sessions which allows for message persistence beyond the duration of client connections, which is optimal for resource and network-constrained scenarios. When a client reconnects to the broker after a network disruption, it will receive all missed messages from the broker's persistence layer. Since all data is sent via the broker, the MQTT broker becomes the single source of truth for all data. Also, through the change of communication structure the problem of point-to-point integrations that was an issue in architectures following the automation pyramid (\autoref{subsection:automation-pyramid}) can be solved. \newline
        
        The messages sent by publishers are addressed to so-called ``topics''. Subscribers can then subscribe to these topics and will then only receive messages addressed to topics they are interested in. A topic is a UTF-8 string that uses the ``/'' separator to support multiple levels where a level might for example be the name of a device or its location. MQTT topics are simple and lightweight - the client does not need to create the desired topic before they publish or subscribe to it. The broker accepts each valid topic without any prior initialization. MQTT also supports wildcards for one or more levels so subscribers can e.g.\ subscribe to all topics related to a certain hierarchy level, which in practice could for example be the name of a physical location. Since topics are very lightweight they can be used in a very specific manner, for example by creating one topic per device \cite{mqtt_topics_best_practices}. A common pattern for topic structures is using the ISA-95 standard which can also be seen in the automation pyramid in \autoref{subsection:automation-pyramid}. Topics can be structured based on the ISA-95 hierarchical structure ``Enterprise/Site/Area/Line/Cell'', which appears to be a perfect fit for MQTT topics in IIoT and will be further discussed in \autoref{section:unified-namespace}. The payload of messages in MQTT is not restricted by the specification in any way and can be filled with any data format, where typically a format like ``Protobuf'' or ``JSON'' is used in practice. In IIoT, all components that used to communicate through bidirectional channels now only talk directly to the MQTT broker. This decouples the components of the system and solves the issue of point-to-point integrations mentioned earlier. Because MQTT was designed for scenarios with unreliable communication, the standard offers three quality of service (QoS) levels. Level 0 follows ``at most once'' semantics, which means that senders attempt to send their messages to the receiver once, without verifying success (``fire and forget''). Note that the receiver can be either a broker, when sending data from a client, or also a client, when the broker delivers data to a client. This level requires the least amount of bandwidth and energy and can be used when the devices are heavily constrained in terms of computational power or network stability and when the loss of a message is not critical. QoS level 1 is the middle ground between 0 and 2 and sends messages with an ``at least once'' approach. Here, senders retransmit messages until they receive an acknowledgment from the receiver. This guarantees that messages will be delivered but comes with the risk of sending duplicates. The highest QoS is level 2 which has ``precisely/exactly once'' semantics. Through a four-way handshake, successfully received messages are first acknowledged by the receiver who also stores the state for the message in order to filter out potentially upcoming duplicates. After the sender acquires the acknowledgment, it then sends a packet instructing the receiver to get rid of its state since it is no longer needed. The sender finishes the four-way handshake by acknowledging that instruction as well. Note that all messages are retried until they are successfully delivered while asserting proper handling of duplicates in this level. This QoS requires the most bandwidth and energy but also has the most intuitive semantics \cite{hivemq_opcua_vs_mqtt_sparkplug}.\newline
        
        Compared to OPC-UA, using the protocol MQTT for central communication in an IIoT system shines through its simplicity. Not only is the protocol MQTT easy to understand, the specification is also strikingly short with only around 80 pages. The use of MQTT in the commonly used standard ``OPC-UA PubSub with MQTT'' shows that MQTT is a good choice for IIoT systems. Despite its simplicity, MQTT still provides many more useful features for IIoT. Through ``retained messages'', the broker can persist the most recent message of a topic. This message, which might for example be the latest reading of a sensor in an IIoT system, is always delivered to new subscribers of the topic, even when no messages are sent by the client after the subscription started. By using ``persistent subscriptions'', the broker can store messages for a client that has a persistent subscription but is offline. Once the client comes back online, all messages stored on the broker will be delivered. This allows for delivery guarantees even in systems with unreliable networks. Lastly, by using the ``Last Will and Testament'' (LWT) functionality, clients can specify a message that will be automatically published by the broker on their behalf, if or when an unexpected disconnection occurs. While devices can be automatically discovered by subscribing to the topic they publish to, their state remains unknown. By sending a message to a topic when coming online and immediately specifying an LWT message for when the client goes offline, each device's state can be automatically discovered by subscribing to the according MQTT topics \cite{hivemq_opcua_vs_mqtt_sparkplug}.
        
    \subsubsection{Sparkplug B}
    \label{subsubsection:sparkplug-b}
    
        While MQTT is fully capable of being the central communication technology of an IIoT system, the ``Eclipse Foundation's Sparkplug Working Group'' created the project ``Sparkplug B'' that aims to improve this capability even further. The Sparkplug B specification describes how edge gateways, native MQTT-enabled endpoints and MQTT applications can communicate using MQTT while keeping focus on IIoT. Its goal is to provide implementation standards based on MQTT to fulfill interoperability requirements in industrial automation. This is achieved by three separate aims of the specification. 
        
        The first aim is to define topic namespaces. MQTT allows any UTF-8 string to be a topic, which stands contrary to the goal of achieving standardization. Sparkplug B solves this by defining a fixed topic structure:
        
        \[
            namespace/group\_id/message\_type/edge\_node\_id/device\_id
        \]
            
        \noindent The enforcement of this topic structure ensures that every communication partner uses the same topic structure thus ensuring standardized communication. While most of the hierarchical layers in the standard are just IDs or names, the ``message\_type'' is another addition by Sparkplug B which can transmit metadata as well as information about the state of a device. The first message type defined in Sparkplug B includes ``birth/death certificates'' for announcing the online/offline status of devices. ``Data messages'' are used for sending standard data payloads. Since only changes in data are sent (report by exception) messages of this type only impose a very small load on the system. ``Commands'' are used to send commands to edge-of-network components or devices which is especially useful in cloud-to-device communication. Lastly, ``state messages'' are used for transmitting the status information of IIoT hosts in environments with multiple, non-cluster-capable brokers. The message type is optional and not used very often. 
        
        The second aim of Sparkplug B is to standardize payload data structures. While MQTT doesn't impose any limitations on the payload format, this can lead to inconsistencies. While JSON is the most popular data format via MQTT, in large projects other formats might be used. Because of this Sparkplug B defines a hierarchical structure for payloads including at least a timestamp, the metric itself and a sequential ID. It is also defined that the data is encoded using ``Protocol Buffers'', more commonly referred to as ``Protobuf''.
        
        Finally, Sparkplug B defines a standard for state management. It specifies an ontology for all communication partners on how to transmit their state over the network. This includes states like the client status and offline-/online state. In practice, this is realized by sending birth/death certificates, last will and testament and retained messages all included in the MQTT standard. \newline
        
        \noindent In summary, Sparkplug B tries to solve MQTT's limitations like lack of object modeling or state management for industrial automation use cases \cite{hivemq_opcua_vs_mqtt_sparkplug}. It is to be noted that in a Sparkplug B-based system, all communication partners must use that standard, whereas sending plain MQTT messages will no longer be supported since it doesn't fit the standards set by Sparkplug B.\ In \autoref{section:unified-namespace} it will be further discussed whether Sparkplug B should be used in a modern IIoT system and which implications it has on such a system in the real world.   